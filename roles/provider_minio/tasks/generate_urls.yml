---
# Generaci√≥n din√°mica de URLs usando mapeos centralizados

- name: üß† Recolectar facts si no est√°n presentes
  ansible.builtin.setup:
  when: ansible_os_family is not defined

- name: Cargar mapeos de instaladores
  ansible.builtin.include_vars: mapping_installers.yml

- name: Validar que el producto existe en los mapeos
  ansible.builtin.assert:
    that:
      - provider_minio_product in global_config.supported_products
      - product_mappings[provider_minio_product] is defined
    fail_msg: |
      ‚ùå Producto '{{ provider_minio_product }}' no est√° soportado.
      Productos disponibles: {{ global_config.supported_products | join(', ') }}

- name: Mostrar informaci√≥n del producto
  ansible.builtin.debug:
    msg:
      - "ü™£ Bucket: {{ minio_bucket }}"
      - "üì¶ Producto: {{ provider_minio_product }}"
  delegate_to: localhost
  run_once: true

# üß™ Simulaci√≥n ‚Äî Saltamos verificaci√≥n de MinIO Client
# - name: Verificar que MinIO Client (mc) est√° disponible
#   ansible.builtin.command: mc --version
#   register: mc_version_check
#   failed_when: mc_version_check.rc != 0
#   delegate_to: localhost
#   run_once: true

- name: Simular cliente MinIO disponible
  ansible.builtin.debug:
    msg: "‚úÖ MinIO Client disponible (simulado)"
  delegate_to: localhost
  run_once: true

# üß™ Simulaci√≥n ‚Äî Saltamos alias
# - name: Configurar alias de MinIO en mc
#   ansible.builtin.command: >
#     mc alias set miMinio 
#     http://{{ minio_host }}:{{ minio_port }} 
#     {{ minio_user }} 
#     {{ minio_password }}
#   register: mc_alias_result
#   failed_when: mc_alias_result.rc != 0
#   delegate_to: localhost
#   run_once: true

- name: Simular alias configurado
  ansible.builtin.debug:
    msg: "‚úÖ Alias configurado exitosamente (simulado)"
  delegate_to: localhost
  run_once: true

# üß™ Simulaci√≥n ‚Äî Saltamos conectividad real
# - name: Verificar conectividad con MinIO usando mc
#   ansible.builtin.command: mc ls miMinio/{{ minio_bucket }}
#   register: mc_connectivity_check
#   failed_when: false
#   delegate_to: localhost
#   run_once: true

- name: Simular conectividad exitosa con MinIO
  ansible.builtin.set_fact:
    mc_connectivity_check:
      rc: 0

- name: Fallar si no hay conectividad con MinIO
  ansible.builtin.fail:
    msg: "‚ùå No se puede conectar a MinIO. Verifica credenciales y conectividad."
  when: mc_connectivity_check.rc != 0

- name: Construir clave del sistema operativo
  ansible.builtin.set_fact:
    os_key: >-
      {%- if ansible_os_family == 'Windows' -%}
        Windows
      {%- elif ansible_os_family == 'RedHat' -%}
        {{ ansible_distribution }}-{{ ansible_distribution_major_version }}
      {%- elif ansible_os_family == 'Debian' -%}
        {{ ansible_distribution }}-{{ ansible_distribution_major_version }}
      {%- else -%}
        unsupported
      {%- endif -%}

- name: Validar que el SO est√° soportado por el producto
  ansible.builtin.assert:
    that:
      - ansible_os_family in product_mappings[provider_minio_product].supported_os
    fail_msg: |
      ‚ùå Sistema operativo {{ ansible_os_family }} no est√° soportado para {{ provider_minio_product }}.
      SO soportados: {{ product_mappings[provider_minio_product].supported_os | join(', ') }}

- name: Obtener ruta del instalador desde el mapeo
  ansible.builtin.set_fact:
    installer_path: "{{ product_mappings[provider_minio_product].installers[os_key] | default(omit) }}"

- name: Validar que se encontr√≥ instalador compatible
  ansible.builtin.fail:
    msg: |
      ‚ùå No se encontr√≥ instalador para {{ provider_minio_product }} en {{ os_key }}.
      Instaladores disponibles para {{ provider_minio_product }}:
      {{ product_mappings[provider_minio_product].installers.keys() | list | join(', ') }}
  when: installer_path is not defined

# üß™ Simulaci√≥n ‚Äî Saltamos verificaci√≥n real del archivo en MinIO
# - name: Verificar que el archivo del instalador existe en MinIO
#   ansible.builtin.command: mc stat miMinio/{{ minio_bucket }}/{{ installer_path }}
#   register: installer_stat_check
#   failed_when: installer_stat_check.rc != 0
#   delegate_to: localhost
#   run_once: true

# üß™ Simulaci√≥n ‚Äî Saltamos generaci√≥n real
# - name: Generar URL pre-firmada del instalador
#   ansible.builtin.command: >
#     mc share download --expire {{ global_config.default_expiry }}
#     miMinio/{{ minio_bucket }}/{{ installer_path }}
#   register: presigned_url_result
#   failed_when: presigned_url_result.rc != 0
#   delegate_to: localhost
#   run_once: true

- name: Establecer URL simulada del instalador
  ansible.builtin.set_fact:
    product_installer_url: "https://minio.fake/{{ provider_minio_product }}/{{ installer_path | basename }}"

- name: Obtener certificados del producto (si existen)
  ansible.builtin.set_fact:
    product_certificates: "{{ product_mappings[provider_minio_product].certificates.get(os_key, []) }}"

- name: Verificar si se deben incluir certificados
  ansible.builtin.set_fact:
    include_certificates: >-
      {{
        (PROVIDER_MINIO_INCLUDE_CERTIFICATES | default(false)) and 
        (product_certificates | length > 0)
      }}

# üß™ Simulaci√≥n ‚Äî Certificados
- name: Establecer URLs simuladas de certificados
  ansible.builtin.set_fact:
    product_certificate_urls: >-
      {{ product_certificates | map('basename') | map('regex_replace', '^(.*)$', 'https://minio.fake/' ~ provider_minio_product ~ '/\\1') | list }}
  when: include_certificates

- name: Establecer lista vac√≠a si no se incluyen certificados
  ansible.builtin.set_fact:
    product_certificate_urls: []
  when: not include_certificates

- name: Mostrar URLs generadas
  ansible.builtin.debug:
    msg:
      - "‚úÖ Instalador {{ provider_minio_product }}: {{ product_installer_url }}"
      - "üì• Certificados: {{ product_certificate_urls | length }} URLs"
      - "‚è∞ URLs expiran en {{ global_config.default_expiry }}"
      - "üîó Bucket: miMinio/{{ minio_bucket }}/{{ installer_path | dirname }}/"
      - "üñ•Ô∏è SO detectado: {{ os_key }}"

# ========= VARIABLES DE COMPATIBILIDAD ==========

- name: Establecer variables de compatibilidad para CrowdStrike
  ansible.builtin.set_fact:
    crowdstrike_installer_url: "{{ product_installer_url }}"
    crowdstrike_cert_urls: "{{ product_certificate_urls }}"
  when: provider_minio_product == "crowdstrike"

- name: Establecer variables de compatibilidad para Nessus
  ansible.builtin.set_fact:
    nessus_installer_url: "{{ product_installer_url }}"
    nessus_cert_urls: "{{ product_certificate_urls }}"
  when: provider_minio_product == "nessus"

- name: Establecer variables de compatibilidad para UIM
  ansible.builtin.set_fact:
    uim_installer_url: "{{ product_installer_url }}"
    uim_cert_urls: "{{ product_certificate_urls }}"
  when: provider_minio_product == "uim"

- name: Mostrar tiempo de expiraci√≥n estimado
  ansible.builtin.debug:
    msg: "‚ö†Ô∏è IMPORTANTE: Las URLs pre-firmadas expiran a las {{ ansible_date_time.iso8601_basic | regex_replace('T', ' ') }} + {{ global_config.default_expiry }}"