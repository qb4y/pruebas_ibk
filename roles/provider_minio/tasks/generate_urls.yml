---
# Generaci√≥n din√°mica de URLs usando mapeos centralizados
- name: üß† Recolectar facts si no est√°n presentes
  ansible.builtin.setup:
  when: ansible_os_family is not defined

- name: Verificar que MinIO Client (mc) est√° disponible
  ansible.builtin.command: mc --version
  register: mc_version_check
  failed_when: mc_version_check.rc != 0
  delegate_to: localhost
  run_once: true

- name: Mostrar versi√≥n de mc disponible
  ansible.builtin.debug:
    msg: "‚úÖ MinIO Client encontrado: {{ mc_version_check.stdout.split('\n')[0] }}"
  delegate_to: localhost
  run_once: true

- name: Cargar mapeos de instaladores
  ansible.builtin.include_vars: mapping_installers.yml

- name: Validar que el producto existe en los mapeos
  ansible.builtin.assert:
    that:
      - provider_minio_product in global_config.supported_products
      - product_mappings[provider_minio_product] is defined
    fail_msg: |
      ‚ùå Producto '{{ provider_minio_product }}' no est√° soportado.
      Productos disponibles: {{ global_config.supported_products | join(', ') }}

- name: Mostrar informaci√≥n del producto
  ansible.builtin.debug:
    msg:
      - "ü™£ Bucket: {{ minio_bucket }}"
      - "üì¶ Producto: {{ provider_minio_product }}"
  delegate_to: localhost
  run_once: true

- name: Configurar alias de MinIO en mc
  ansible.builtin.command: >
    mc alias set miMinio 
    http://{{ minio_host }}:{{ minio_port }} 
    {{ minio_user }} 
    {{ minio_password }}
  register: mc_alias_result
  failed_when: mc_alias_result.rc != 0
  delegate_to: localhost
  run_once: true
  # no_log: true

- name: Mostrar resultado de configuraci√≥n de alias
  ansible.builtin.debug:
    msg: 
      - "‚úÖ Alias configurado exitosamente"
      - "üì§ Salida: {{ mc_alias_result.stdout if mc_alias_result.stdout else 'Sin salida' }}"
  delegate_to: localhost
  run_once: true

- name: Verificar conectividad con MinIO usando mc
  ansible.builtin.command: mc ls miMinio/{{ minio_bucket }}
  register: mc_connectivity_check
  failed_when: false
  delegate_to: localhost
  run_once: true

- name: Mostrar resultado de conectividad
  ansible.builtin.debug:
    msg:
      - "üîç C√≥digo de salida: {{ mc_connectivity_check.rc }}"
      - "‚úÖ Salida: {{ mc_connectivity_check.stdout if mc_connectivity_check.stdout else 'Sin salida' }}"
  delegate_to: localhost
  run_once: true

- name: Fallar si no hay conectividad con MinIO
  ansible.builtin.fail:
    msg: "‚ùå No se puede conectar a MinIO. Verifica credenciales y conectividad."
  when: mc_connectivity_check.rc != 0

- name: Construir clave del sistema operativo
  ansible.builtin.set_fact:
    os_key: >-
      {%- if ansible_os_family == 'Windows' -%}
        Windows
      {%- elif ansible_os_family == 'RedHat' -%}
        {{ ansible_distribution }}-{{ ansible_distribution_major_version }}
      {%- elif ansible_os_family == 'Debian' -%}
        {{ ansible_distribution }}-{{ ansible_distribution_major_version }}
      {%- else -%}
        unsupported
      {%- endif -%}

- name: Validar que el SO est√° soportado por el producto
  ansible.builtin.assert:
    that:
      - ansible_os_family in product_mappings[provider_minio_product].supported_os
    fail_msg: |
      ‚ùå Sistema operativo {{ ansible_os_family }} no est√° soportado para {{ provider_minio_product }}.
      SO soportados: {{ product_mappings[provider_minio_product].supported_os | join(', ') }}

- name: Obtener ruta del instalador desde el mapeo
  ansible.builtin.set_fact:
    installer_path: "{{ product_mappings[provider_minio_product].installers[os_key] | default(omit) }}"

- name: Validar que se encontr√≥ instalador compatible
  ansible.builtin.fail:
    msg: |
      ‚ùå No se encontr√≥ instalador para {{ provider_minio_product }} en {{ os_key }}.
      Instaladores disponibles para {{ provider_minio_product }}:
      {{ product_mappings[provider_minio_product].installers.keys() | list | join(', ') }}
  when: installer_path is not defined

- name: Verificar que el archivo del instalador existe en MinIO
  ansible.builtin.command: mc stat miMinio/{{ minio_bucket }}/{{ installer_path }}
  register: installer_stat_check
  failed_when: installer_stat_check.rc != 0
  delegate_to: localhost
  run_once: true

- name: Generar URL pre-firmada del instalador (expira en {{ global_config.default_expiry }})
  ansible.builtin.command: >
    mc share download --expire {{ global_config.default_expiry }}
    miMinio/{{ minio_bucket }}/{{ installer_path }}
  register: presigned_url_result
  failed_when: presigned_url_result.rc != 0
  delegate_to: localhost
  run_once: true

- name: Establecer URL de descarga pre-firmada del instalador
  ansible.builtin.set_fact:
    product_installer_url: "{{ presigned_url_result.stdout_lines | select('match', '^Share:.*') | first | regex_replace('^Share: ', '') }}"

- name: Obtener certificados del producto (si existen)
  ansible.builtin.set_fact:
    product_certificates: "{{ product_mappings[provider_minio_product].certificates.get(os_key, []) }}"

- name: Verificar si se deben incluir certificados
  ansible.builtin.set_fact:
    include_certificates: >-
      {{
        (PROVIDER_MINIO_INCLUDE_CERTIFICATES | default(false)) and 
        (product_certificates | length > 0)
      }}

- name: Verificar que los certificados existen en MinIO
  ansible.builtin.command: mc stat miMinio/{{ minio_bucket }}/{{ item }}
  register: cert_stat_results
  loop: "{{ product_certificates }}"
  failed_when: cert_stat_results.rc != 0
  delegate_to: localhost
  run_once: true
  when: include_certificates

- name: Generar URLs pre-firmadas de certificados
  ansible.builtin.command: >
    mc share download --expire {{ global_config.default_expiry }}
    miMinio/{{ minio_bucket }}/{{ item }}
  register: cert_presigned_results
  loop: "{{ product_certificates }}"
  failed_when: cert_presigned_results.rc != 0
  delegate_to: localhost
  run_once: true
  when: include_certificates

- name: Establecer URLs de certificados pre-firmadas
  ansible.builtin.set_fact:
    product_certificate_urls: "{{ cert_presigned_results.results | map(attribute='stdout_lines') | map('select', 'match', '^Share:.*') | map('first') | map('regex_replace', '^Share: ', '') | list }}"
  when: include_certificates

- name: Establecer lista vac√≠a de certificados (si no se incluyen)
  ansible.builtin.set_fact:
    product_certificate_urls: []
  when: not include_certificates

- name: Mostrar URLs generadas
  ansible.builtin.debug:
    msg:
      - "‚úÖ Instalador {{ provider_minio_product }}: {{ product_installer_url }}"
      - "üì• Certificados: {{ product_certificate_urls | length }} URLs {{ 'generadas' if include_certificates else 'saltadas' }}"
      - "‚è∞ URLs expiran en {{ global_config.default_expiry }}"
      - "üîó Bucket: miMinio/{{ minio_bucket }}/{{ installer_path | dirname }}/"
      - "üñ•Ô∏è SO detectado: {{ os_key }}"

# ========== VARIABLES DE COMPATIBILIDAD ==========
# Para mantener compatibilidad con roles existentes

- name: Establecer variables de compatibilidad para CrowdStrike
  ansible.builtin.set_fact:
    crowdstrike_installer_url: "{{ product_installer_url }}"
    crowdstrike_cert_urls: "{{ product_certificate_urls }}"
  when: provider_minio_product == "crowdstrike"

- name: Establecer variables de compatibilidad para Nessus
  ansible.builtin.set_fact:
    nessus_installer_url: "{{ product_installer_url }}"
    nessus_cert_urls: "{{ product_certificate_urls }}"
  when: provider_minio_product == "nessus"

- name: Establecer variables de compatibilidad para UIM
  ansible.builtin.set_fact:
    uim_installer_url: "{{ product_installer_url }}"
    uim_cert_urls: "{{ product_certificate_urls }}"
  when: provider_minio_product == "uim"

- name: Mostrar tiempo de expiraci√≥n estimado
  ansible.builtin.debug:
    msg: "‚ö†Ô∏è IMPORTANTE: Las URLs pre-firmadas expiran a las {{ ansible_date_time.iso8601_basic | regex_replace('T', ' ') }} + {{ global_config.default_expiry }}"